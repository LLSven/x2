2017年11月24日02:51:50：23日的工作现在结束，已修改的bug如上所述，明天应当继续就MBR VBR的设计继续，逐步引入文件系统。今天留下的代码没有产生错误。
2017年11月24日02:49:20：今天看上去做了点事情，但实际上又是在调bug的一天。来做点规定吧：
        恢复正常的作息习惯，无论有什么bug，将状态记录下（为了第二天恢复），然后必须关闭电脑。
        这是第一原则，健康、可持续。          【未完成】
2017年11月24日02:03:24：修复了一个bug：在实模式下清空prefix区时，由于基地址是0x7c00，而不是0，导致写错了。
        为此，我们再提出一个原则：完整地描述所有约束，所有涉及的寄存器。内存，就需要知道段寄存器的值。

2017年11月23日17:48:43：现在开始设计第二层引导器
    MBR存储分区信息和1级加载代码
    1级加载代码加载后序的实模式代码1，并跳转到起始处
    实模式代码1将堆栈指针重置，避免分区信息被覆盖
    实模式代码1将扇区信息存储到堆栈之后的第1个扇区，该扇区将用于2级加载代码的数据，找到第一个active的分区
    加载该分区的第1个扇区，即2级加载代码，到0x7c00处，跳转到0x0:0x7c00处
    2级加载代码必须知道/boot分区的位置，这个信息在该扇区的末尾存储，即存储了/boot代码的信息
    2级加载代码现在已经有了堆栈区，一个数据区，所以其后序代码被加载到之后的第一个扇区，加载/boot代码，然后跳转程序区
    /boot代码要求与文件系统协作：文件系统必须在根目录下分配一个文件，并且要求没有碎片。

    /boot代码现在已经找到，后序就是加载文件系统。需要动态（以文件名方式而不是扇区方式）找到kernel，kernel可以由文件路径指定，默认值存储在第一个扇区的末尾，最长MAX个字符，最后一位为0

    文件系统的MBR类
2017年11月23日15:58:46：改进1：将prefix区在保护模式下初始化为0
            改进2：使用as --defsym SYM=VAL来传递宏参数，为了兼容，必须使用已经计算好的数值
            改进3：
            改进4：对Makefile进行文档说明                             【未完成】

            改进5：ld应当也可以传递符号，从而ld脚本文件中也可以使用宏                 【未完成】
            改进6：改进ljmp的实现，一个特殊实现是只改变cs的值，eip照常增加                    【未完成】
            改进7:16位模式的栈区大小可以任意改变，因为现在不再依赖特定的ld脚本的起始地址安排，而是通过源文件中.org指令进行安排
2017年11月23日06:47:48：可能KernelMMNode的指针域没有初始化为NULL,alloc域没有初始化为false有关    请检查所有的该类代码  【未完成】
2017年11月23日05:18:20：验证了每次磁盘读入不能超过250扇区的问题，同时，使用重复读避免了这个问题
    增加了栈的大小，为10
    但是只要能够载入第二段保护代码，都可以。
    很有可能前面的错误与老旧的IDT设置有关
2017年11月23日04:26:40：目前错误发生在4个扇区的栈不够用
2017年11月23日03:59:04：在内核的kernel建立之前，不能调用dumpInfo，因为此时MemoryManager还没有建立
2017年11月23日03:12:50：我现在还是没弄明白TLD的工作原理，这个先暂时标注未完成，将代码改成0x300000处（暂时），之后再回来修改。 【未完成】
2017年11月23日02:37:15：我怀疑这是PTE缓存的问题，因为0x100000曾经用来映射PTE，要验证这一点，只需要将其改成0x200000试试
        问题果然如此，看来得查一下intel手册，具体怎么更新虚拟内存。
        PCID：用于标注CR3改变时的程序状态，对于32bit paging而言，它总是0
    TLB保存线性地址到物理地址的映射，以此加速程序
INVLPG. This instruction takes a single operand, which is a linear address. The instruction invalidates any TLB
entries that are for a page number corresponding to the linear address
清除所有对应同一个  page number

2017年11月23日01:20:54：二维数组怎么传递？现在暂时不会，原来类型错误

2017年11月23日01:06:51：内存管理器有一个bug,在kernel初始化过程中，内存管理器在设置其已使用的状态之前被调用。正确的方式是：在初始化过程中设置已经分配的节点
但是我又发现不是这个问题，因为本来空闲内存就是1~3m,不会与内存冲突

2017年11月22日23:22:44：留下一件事情：如果要分配N个连续的PTE，必须保证这些PTE不跨越4KB分区，所谓的PTE连续性。

2017年11月22日23:01:23：现在我们对虚拟内存有了更新一步的认识，实际上CR3,PDE,PTE的低12位都是偏移，因此高20位决定了它们的第0项所在；只有从第0项开始才能在一项（而不用增加到下一项）完整地获得该项所能访问的所有页面，比如，只有PDE0位于4KB的整数倍才能用1个PDE访问4MB,否则偏移多少都需要另一个PDE来补偿；只有PTE0位于4KB的整数倍才能完整地访问4KB。

2017年11月22日22:17:12：视频缓冲区选择子错误
    PDE0能够管理4MB
    必须有一项新的PDE来管理

2017年11月22日21:53:16：ljmp似乎出现错误
    __asm__ __volatile__(
            "pushw %%cx \n\t"
            "push  AFTER_JMP \n\t"
            "ljmp *(%%esp) \n\t"
            "AFTER_JMP:\n\t"
            :
            :"c"(Util::makeSel(2))
            :
        );
    原因在于push AFTER_JMP这句话，其含义并不是push标号，而是push这个内存的指针，加上$正确, push $AFTER_JMP
      
2017年11月22日21:15:24：如何解决当虚拟内存开启以后线性地址和虚拟地址不相同的问题？
    我们作一个暂时的过渡：假设访问物理0地址，其线性地址就是0；现在Cr3已经确定，所以PDE0必然在0处，但是PTE该放在哪里呢？
    PTE我们将其放到空闲内存区域（内核代码结束处），从而暂时形成虚拟地址=线性地址
    下一步，重新构造gdt表，更改相关项的其线性地址
    重新加载cs，ds,ss即可
    cs的加载使用ljmp *(%esp)即可

2017年11月22日19:37:48：现在由于一开始实模式只加载很少的扇区数目，导致IOHD类还不可用，解决办法是将其放到前面的10个扇区内。

2017年11月22日17:03:58：增加概念文件，用于解释各个名词

2017年11月22日16:47:31：
    初始栈大小至少是4个扇区，这必须保证
    现在，临时将引导代码放到栈的低2个扇区，然后借此跳转到protected_main的主程序
    但是必须保证前0x500的数据区域不能被覆盖，因此要求只能跳转到代码区的第一行。
    保护模式代码区必须是512的倍数，因此如果获得sizeof().data区的大小，就能安排text区的位置，然后这个变量应当被告知实模式。
2017年11月22日16:07:25：不要依赖于汇编符号
    如果依赖，要把机制讲清楚。
    使用g++ -m32，符号机制如下
    1.extern "C"{
        void foo();
    } 用于声明函数，之后该函数的定义出现的汇编符号是_foo。 参见protected_main的开头extern "C"部分
    2.汇编代码：
         .global _X
        _X:
    如此引用，X在C中必须写成extern int x; 并且要获得地址值，只能使用&x
    这个地址只能用于运行时，编译器不能使用。

2017年11月22日13:52:54：考虑使用vc编译器是否也能编译？
    extern char p[];
    char p[20];
这两句一句用于声明，一句用于定义


2017年11月22日13:45:21：使用了make的eval，foreach两个命令来改善CONFIG_XXX变量的定义，现在所有的CONFIG_变量被放到Config.makefile中，Makefile的include/config.h 能够自动生成这些变量的g++编译错误信息

2017年11月22日10:33:40：正在进行目标18，改进内核设计


2017年11月22日03:24:55：键盘输入的这种设计，完全有可能使其成为经典。

2017年11月22日03:11:53：完成了键盘字符的处理，处理逻辑如下：
    键盘的键分为两类：普通的键和控制键
    键盘上的Shift，Ctrl，ALT，CAP，NUM等键属于控制键，只有控制键和普通键一起才能够确定一次输入，所以控制键的状态就相当于输入的上下文，每一个输入的字符必须“记得”输入它时的环境。因此，内核使用2个字节来存储1次输入：1次输入只有8个字节，但是使用额外的8个字节来存储输入上下文，也就是控制键的信息。参见IOProgrammer::Keyboard的说明。

2017年11月22日02:03:46：从现在起，我们增加一条原则：只相信可以调试的代码是好代码。
    增加一个一键清屏的功能，跟切换差不多
    把程序的可调试性放到第一位
    先实现无阻塞的getChar()
2017年11月21日20:14:03：完善键盘中断处理程序，建立输入缓冲区（长度N := 512）,
    计划开发一个可以显示n页的缓冲区，因为一页=80*25=2000个字符；最初我们配置P:=3页来作为寄存缓冲区，并用变量w来表示当前显示的页面。切换时，将当前页的内容保存到相应缓冲区，然后读入新页即可。
    建立程序，使ctrl+alt+del产生时，重启系统
    .S文件允许调用CPP处理，可以试一下。

    设计一个读取函数,char getChar(char & specialKeys);用于判断是否有特殊字符
    对special， 0:ctrl 1:alt 2:rightctrl 3:rigthalt

    系统输入缓冲区（一个队列），定义成一个固定的长度n=512，占据一个扇区；
    由输入缓冲区的设计想到，其实不必大费周章地定义各个扇区的长度等信息，只需要在一个文件中物理地把这些数据定义出来，然后把他们放到合适的偏移处（依据ld文件）
    键盘输入的处理实例和逻辑：
        ctrl+p   会产生一个ctrl 以及很多 p，这里规定，在ctrl shift按下后，多次重复的普通键被抛弃，


2017年11月21日18:49:09：版本号从0.18上升到0.20

2017年11月21日16:57:06：修复了几个小bug，prepare...函数的完成
    现在，执行到用户进程时，第一句push %ebp,总是出现错误码为0x3b3的13号中断。不知道为什么。
    什么是Stack？-- 指的是由SS指向的数据段，本质上是一个数据段
All data segments are nonconforming, meaning that they cannot be accessed by less privileged programs or procedures (code executing at numerically higher privilege levels). Unlike code segments, however, data segments can
be accessed by more privileged programs or procedures (code executing at numerically lower privilege levels)
without using a special access gate
    所有的数据段都是非一致的，意味着它们不能由更低权限的程序访问。（0能访问3，但是3不能访问0）。
limit的解释：向上扩展的段（一般的段）,limit是所能访问的最后一个字节地址，访问范围是0~limit，大于limit的会产生GP异常（非SS段）或者SS异常（对SS段）；向下扩展的段，....
    
    对上面push的理解，应该是eflags的问题，中断应当不被允许，否则一进来就执行中断。 -- 把push ebp改成了jmp . - 2也产生同样的错误。与栈无关，是eflags允许了外部的中断。eflags的第9位（从0开始）为IF，需要把IF设置成0

    现在发生的是14号错误, 错误代码0x0101 意味着是一个读错误，是USER-MODE引起了这个错误

    可能是4.6.1节所描述的Access Mode的错误。当PDE，PTE的U/S标识（第2位）为0时，是管理模式，需要CPL<3；=1,是用户模式，CPL=3。
    PDE1应当设置U/S=1
    PDE1的所有PTE也应当设置U/S=1 ( &0xfffffffffb)
    问题正是这个。
    至此，目标1完成。       【目标1完成】


2017年11月21日11:57:15：内核有一个PDEManager，管理80个PDE项。其第0项有一个PTEManager，长度为768,6个扇区，不为空；其余的均未初始化

2017年11月21日01:37:13：目前来看，进程之所以切换错误，是由于虚拟内存设置错误。
    为了使进程能够访问自己所在的空间，共24个扇区，3页，需要请求kernel分配一个pde项，然后请求分配一个在4字节上对其的pte项
    现在新建了一个24扇区的进程结构，
        在切换时，进程使用了自己的LDT上的cs。进程LDT布局：0-NULL 1-CODE 2-DATA 3-STACK 4-SYS STACK
        进程使用了pbase这个局部变量作为自己的线性起始地址，这个地址时线性地址，可用于反向确定CR3的值。
        首先，进程需要访问内核数据吗？只要CR3+L1能够找到绝对地址0，则就行；所以CR3，L1必须定位到0处
    切换过程中，GDT表的地址会变化吗？
        虚拟内存策略：进程的PDE，PTE需要自己管理，统一放到起始位置处，10个PDE，之后是第1个PDE的PTE
        这样一来，PDE的绝对地址确定，PTE的绝对地址确定，进程的起始地址确定，从而CR3,L1,L2,L3也都确定。
        LDT线性起始地址的设置由：


2017年11月21日01:07:52：修复了一个bug：Kernel中的newgdt初始化默认参数和SegmentDescriptor相差一个，导致一直无法找到错误。
    这说明两点：在大型工程中，任何错误都是致命的，最后你总会发现自己是在犯低级错误
            代码唯一性原则很重要，不要维护双胞胎代码（孪生代码）。

2017年11月21日00:17:30：增加一项调试规则：insertMark 依据当前文件名的第一个16进制字符（如果没有则是a），然后依据行号，重复两遍。

2017年11月20日23:59:28：虚拟内存的理解又占据了大部分时间。我发现工作效率与工作方式有关，对于虚拟内存这种概念的理解，只要列出了公式，其实一目了然，然而光靠想是不可能理解的。
    目标1完成了大部分了，备注部分已经完成
    一个PDE必然要连续的管理1024个PTE项。


2017年11月20日18:38:57：磁盘读写不正确，先将内核大小改成250。 查找保护模式的第x个扇区，等于在原文件中查找第x+25个扇区；
在原main.bimg中查找x处的位置，等于在bochs中查找 32-25+x的位置
就目前来看，300有错误，250可以正确读入。--250目前足够满足要求。

2017年11月20日14:26:19：继续，创建一个新的进程，然后执行。从本质上来说，就是1.切换到用户态  2.改变cs,eip的值  3.载入tss
    现在有一个进程：Util::jmpDie(),  Util::insertMark(0xCCCC);  只要停在CCCC的前一步就算成功了。
    编译这个程序，最终占用了16个扇区，从425到其后的16个扇区。根据ld文件来看，前4个扇区是栈和其他内容区域，后面是代码
    新建一个进程时：输入参数有  栈区，数据区，代码区的Limit和起始地址
    过程：
        Process的初始化过程

2017年11月20日13:33:55：修改所有路径，现在规定，如果在windows下，必须放到C盘，且路径中不能含有空格等特殊字符，将-作为连字符

2017年11月20日12:37:44：想来想去，还是必须实现CODE32USER,因为确实某些代码不能完全链接到用户态    【完成】


2017年11月20日02:11:27：目标16， 把Bochs-2.6.9复制到了tools目录下，从而只使用相对路径； 为了生成main.bimg文件的原本，不再使用不跨平台的bximage，而是使用已经生成的文件，不能删除该文件


2017年11月20日01:33:55：令人失望的是，eclipse并不能在编辑阶段指定编译器的语言标准。只能通过分析build来检测。

2017年11月20日01:04:45：我睡不着，我只有继续编程才能睡下，我接受这个现实。
    其实编程的目标，并不是懂得什么，而是理解解决问题的最有效的方法。

2017年11月19日22:31:52：我希望创建一个进程，至少能够进入执行它的一部分开始的代码。【未完成】
为了创建一个新的进程，必须知道它代码的地址（现在所有的内容都存在于内存中，不涉及外部磁盘读写问题），pid等，构造ds，cs，ss三个段选择子，指向该进程所在的地址，然后将进程加入到队列中或者直接切换到该进程。
进程映像：所谓进程映像是指进程作为一个可单独载入的程序的内存布局。

2017年11月19日22:24:03：现在已经启用了虚拟内存，我想访问4MB开始处的4个字节，有办法做到吗？--成功了，先在GDT表中申请一项，然后利用返回的值作为选择子设置

2017年11月19日18:56:29：修复了一个bug，PMLoader::SMM_NODE_SIZE应当使用FullNode，之前使用部分，只得到28，有一定的错误。
2017年11月19日21:52:39：修复了一个bug（又是花了很久时间），保护模式代码过度膨胀导致原来的扇区不够用，只有在进入汇编模式调试后才发现同样地址的内容不相同。 现在，保护模式代码占据了400个扇区，有一点改进，应当根据gen/32/main.bimg文件的大小(/512)来设置。

2017年11月19日18:17:51：修复Kernel初始化的bug

2017年11月19日17:05:58：搞清楚运行流程


2017年11月19日13:17:33：整体先make，使镜像文件先运行

















