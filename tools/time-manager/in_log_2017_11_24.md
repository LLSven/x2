



2017年11月26日15:33:54：
一个小bug，malloc得来的内存，如果写超限，不会报错
但是free错误


2017年11月26日15:10:46：
修复了一个小bug，在定义函数时，使用::free而不是free


2017年11月26日15:00:04：
64位系统上应当使用fopen("file","r+")来读写之前的文件


2017年11月26日13:37:58：
现在，看上去SimpleMemoryNode配合其他类型是非常有效的方式，但是实际上非常愚蠢，这破坏了类的封装原则。

建议：所有的该类管理器换成Associate型管理器  【未完成】


2017年11月26日13:37:31：
解决了一个在类定义中引入其他的文件的bug
2017年11月26日11:04:56：
依赖图（不是依赖的问题）

File.h-->MallocToSimple.h
        |
        -->def.h
        |
        -->MemoryManager.h
        |
        --List.h
        |
        --Env.h
                            -->List.h
                            |
        -->MallocToSimple.h--->EnvInterface.h--def.h
        |
Env64.h-->Env.h-->def.h





2017年11月26日08:07:41：注，文件系统的filename分区是 <len,data>结构，而不是<data,0>

2017年11月25日23:42:12：EnvInterface中，应当将地址类型修改成系统的指针类型，也就是sizeof(void*),否则在64位系统上可能出现截断错误
直接将类型限定为u8_t*即可

2017年11月25日23:09:44：对于某种类型的文件，如果决定只在有限的模式下编译通过，则增加
```c++
\#if !defined(CODE64)
\#error "SPECIFIC for CODE64"
\#endif 
```
     【未完成】

2017年11月25日21:24:45：暂时将字符串处理为char数组和其长度，string类型之后再处理。

2017年11月25日17:59:29：总结一个设计原则：接口和实现分离在c++中也有较好的实现
2017年11月25日17:57:04： 目前已经完成了大部分文件系统的重构
内置一个env变量，不再有任何其他假设，不引入其他文件，除了Environment。
这就是接口设计的好处

2017年11月25日14:11:17：
EnvInterface需求分析
注：元信息的内存缓冲区分配以及信息的读入，这些由外部完成
写扇区 -- 将文件内容从内存位置写的扇区的某个位置
writeSectors(u32_t srcSeg,u32_t srcOff,u8_t driver,u32_t LBAlow,u32_t num,u32_t LBAhigh)

readSectors(u32_t dstSeg,u32_t dstOff,u8_t driver,u32_t LBAlow,u32_t num,u32_t LBAhigh);


int printf_simple(const char *fmt,...);

一个SimpleMemoryManager<TreeNode<MemoryDescriptor>>,一个SimpleMemoryManager<ListNode<LinearSourceDescriptor> >
T *getNew();
void withdraw(T *t);

这样一来，filenamemm将不知道具体的SimpleMemoryManager的类型

只需要继承MallocToSimple即可
将这个参数传递进去。。。

支持的string类型：即String Interface

回写操作可能按文件回写，也可能按磁盘回写；
64位系统忽略磁盘号，以文件名替代之；或者说，将磁盘号转换成文件名，将(LBA扇区号-[该分区起始扇区号])*512转换成文件偏移，将num转换成字节数量偏移即可

TreeNode<MemoryDescriptor> 
ListNode<LinearSourceDescriptor> 


一个简单版的printf函数，仅仅支持%x,%d,%c三种类型,用于输出调试信息。 

这些函数绝对不能作为宏实现

初始化前提假定：已经分配好了所有的元信息区域

2017年11月25日13:42:15：先测试64位模式下的读写，
增加命令
然后将所有用到的64位代码提取成EnvInterface
改变文件系统的实现，使用动态参数，这些参数一经指定，就写入第三个扇区
增加X2fsUtil的功能：读取元信息     【未完成】

2017年11月25日03:34:05：其实从整体来看，需求就是要求gcc能够尽量压缩代码的空间，不要将代码放到其他区域

2017年11月25日02:55:00：现在通过扩展的int0x13的42号中断来完成功能。
需要在将来添加检测0x13扩展中断的代码    【未完成】

2017年11月25日02:33:07：尝试在VS下编译整个工程
因为我发现eclipse并不是特别高效。    【未完成】

2017年11月25日01:20:57：启用编译器中的-Wall选项，启用全部警告信息     【完成】
同时启用了-Werror, 取消了--no-warnings

2017年11月25日00:59:13：
读取参数：dl=01 一个驱动器 dh=0xf
di=0xffac es=0x7c0
cx=0x133f
CF=0
bl=0

柱面：0x13
扇区数：0x3f
磁头数：0xf

2017年11月25日00:22:51： cx=554d, 但是开始扇区是0x3000

2017年11月25日00:17:47：此次MBR完成后，有必要在filesystem手册中增加一章详细的技术说明
包括禁止g++代码重排
启用-O优化，视情况选择合适的
其他一些语言上习以为常的事情必须经过检验。

2017年11月25日00:03:34：review所有的代码，确保使用char作为内部成员时，是无符号类型的，即u8_t

2017年11月24日19:39:36：现在将partitions_table文件删除，使用新的镜像文件替代之

2017年11月24日19:23:26： 使用g++的文件宏定义替代命令行参数传递   【未完成】

2017年11月24日19:20:04：从linux下新建了一个磁盘文件，用于替代旧的tools/bochs-run/main.bimg.clean文件
该文件的分区信息包括在同目录下的main.bimg.clean.info中

2017年11月24日16:04:19：修复了memcopy使用esp位置相关参数的bug

2017年11月24日15:26:27：基于MBRmain.cpp文件，针对该文件，是否可以启用优化选项？
2017年11月24日14:05:45：编译出VBRmain.bimg文件，然后将原来main.cpp(16位引导文件)修改成跳转到VBRmain.bimg文件
现在需要知道具体的分区信息，MBR明确地只能占用一个扇区，因此代码量不能过于庞大
确定激活扇区的位置，然后读入该扇区；为了仍然将其读到0x7c00处，所以MBR扇区的代码和栈需要移动到后面（栈之后的位置），然后跳转到该处继续执行，所有代码不能超过分区大小。

将main.cpp修改含义更加明确的MBRmain.cpp,生成文件名也改变  【完成】

image_16.ld改成image_mbr.ld 【完成】
image_32.ld改成image_kernel.ld 【完成】
2017年11月24日14:03:07：重新定义了表格准则法形式，现在放在一个文件文件夹中，对应pre,in_log,post三个过程
in_log可以附带后缀下标，表明时间区间
