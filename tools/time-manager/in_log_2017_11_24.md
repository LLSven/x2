







2017年11月29日00:05:19：
我感觉必须重新对文件系统的设计进行阐释

2017年11月28日23:59:12：
修复了原来文件系统中存在的微小错误：
link分区以0~len初始化，但是第一次分配总是返回0，而这被视为NULL
后面要做的事情：确保传入开始为NULL的管理器初始化值     【未完成】



2017年11月28日18:55:54：
C++ Primer 5读完，感觉对C++有了一个全局的概览，而且感觉这个全局十分广阔。
C++必知必回 -- 有点枯燥，以后再看

--------暂停阅读这些书籍，回到实现上。


2017年11月28日14:50:59：C++比较复杂而不实用的部分
5类资源控制函数：拷贝，赋值，移动，析构，运算符
重载运算符（仅在少数情况下有用）
类型转换运算符重载






2017年11月28日02:40:11：
尝试引入lambda,initializer_list，看看在无c++环境能否使用       【未完成】



2017年11月28日02:24:22：
尝试使用预处理生成文件，获取标准库的实现方式。

2017年11月27日21:26:19：
dynamic_cast/命名转换这一部分并不是很清楚


2017年11月27日20:54:22：
修复了一个bug，错误地使用了!来替换~位运算符。
经测试，!作为一个逻辑操作符，其结果只有两个值：0或1，!p=(p==0?1:0).
!决定不是位运算符。

2017年11月27日20:29:07：
下一步应当首先实现x2::string,使其符合std::string接口，另外还有vector
鉴于printf的不可靠，转而实现标准库的iostream


2017年11月27日18:57:55：
我有一个想法，我们经常忘记语言，但是又能很快回忆起来。我们可以做一个热身项目，即在很久没有使用某个语言后，只有按照指导进行这个热身项目，就能让我们getPrepared。       【未完成】
c++使用一个指导文件：Tutorial_c++.md


2017年11月27日17:31:48：
开始读书计划

2017年11月27日16:43:45：
完成了对所有size_t依赖的类的重新构造，
现在它们依靠__SizeType参数进行动作，从而避免了二义性

不要使类型具有二义性  将其加入最佳实践建议【未完成】

2017年11月27日16:19:25：
为了带有模板的类容易修改，需要做到以下几点：
1.考虑一个原来不是模板的类变成模板
2.考虑一个原来是模板的类尾部增加参数
3.考虑一个原来是模板的类减少参数
4.考虑一个原来是模板的类去掉模板

如果一个方法中出现了对一个类模板的引用，比如在方法get()中，出现return Tree<int>::get
则Tree<int>修改不安全的，应当将Tree<int>定义成 __Tree

将这个总结为一条实用的规则       【未完成】

2017年11月27日16:00:37：
读书计划
C++ Primer 5
C++编程思想
模板C++
Effective C++
More Effective C++

要使用在阅读中获得技术来改善自己的设计



2017年11月27日15:36:24：
x2绝对不仅仅是一个实验性质的软件程序，而更加是一个充满了设计上完善的艺术作品。


2017年11月27日15:24:13：
所有平台相关的部件：--封装成SizeType
指针类型的长度，这决定了寻址范围


与操作系统相关的部件：--封装成EnvInterface
内存管理
字符串打印
time函数



与平台无关的部件：--无需封装
LBA地址 64位
磁盘的空间64位
一个字节的长度永远是8位


如果一个类需要使用上面有依赖参数中的任何一个，必须使用参数封装。
一个是TypesInterface,一个是EnvInterface
两个加起来构成了具体的上下文环境





2017年11月27日15:23:21：
技术和技术产生的东西同样重要


2017年11月27日15:19:00：
__SizeType 必须以无符号类型实现


2017年11月27日14:52:01：
文件系统可以是仅仅依赖某个平台的
也可以是跨平台的，

但是只能高位平台向下兼容，而低位平台无法使用高位平台的东西。

试想：如果一个文件系统专门用于某个平台下，那其IO性能就有所提升

2017年11月27日14:27:55：
c++标准库是怎么实现的？技术、方法和哲学

《当你实现标准库：方法与建议》




2017年11月27日13:26:16：
现在，所有的类，都必须保证能够在不同平台上使用
因此，不能直接使用任何系统相关的具有固定长度的类型，通过模板参数来指定要使用的类型

假定1：SizeType长度等于u8_t*长度，也就是指针长度等于最长长度，也就是系统的位数

将所有的类改成符合上面要求的结构    【未完成】
具体来说，所有的size_t类型都是不安全的,需要使用模板参数__SizeType来替代

注：有一种色盲叫做不分青红皂白


2017年11月27日13:02:59：
文件系统需要跨架构，所以其中的每一个结构都应当具有与平台无关的大小，即sizeof对其中的每个结构，在不同平台上都返回相同的值

在文件系统中，不要使用指针类型。

LinearSourceDescriptor应当成为泛型，以基本类型为模板参数



2017年11月27日11:54:07：
对于文件系统，仍然可以采取与内存管理相同的思想
使用链表管理器来管理。
内部优化：当某个管理器的节点回收数目超过一半时，就可以将其调整到链表的尾部，下次使用该分配器进行分配。
这样带来的问题是，调整分区偏移时，各个指针的基址不一样，虽然这可以解决，但是仍然有些麻烦。
一种简单的做法是，在分配时所有的区都以同一个缓冲区作为基址，所有的区都分配的一个连续的区域。
原来的区如果不够用，就需要调用realloc函数来重新分配空间，然后所有泄露的节点，必须重新获取或者调整偏移。因此节点泄露越少越好。
还可以设置一个回调函数，当偏移大调整时，调用已经注册的函数对偏移调整函数进行反应。          
                                【未完成】

2017年11月27日01:44:07：
到目前为止，对vs，clion的尝试都算是失败了
但是仍然可以看到clion一些吸引人的地方
它有console，有cmake，理论上eclipse的build其实就是加一个文件来引用原来的makefile文件而已

而clion可能具有更好的代码分析和编辑功能。

2017年11月27日01:13:07：
https://packagecontrol.io/packages/Theme%20-%20One%20Dark  sublime one dark

开启windows的放大镜反色效果，就是夜间模式
保护眼睛



2017年11月27日00:26:22：
文件系统由于env提供了读写扇区的完整能力，所以它的命令行界面有能力增加一个从文件读写到扇区的功能。

但是也可以不必如此。

2017年11月27日00:17:55：
eclipse--the best of simple, the simple of best

2017年11月26日18:19:58：
操作系统具有自扩展的能力。
内存管理就是一个很好的话题，一开始内存管理基于有限的节点；

现在，我们改进内存分配器的工作方式，使用一个SimpleMemoryManager链表，当最后一个SimpleMemoryManager不足时，就先申请一个新的SimpleMemoryManager,然后使用新申请的SimpleMemoryManager来分配节点。

当节点减少到0时，暂时保留这个SimpleMemoryManager；如果前一个SimpleMemoryManager节点已经减少为0，则取消此SimpleMemoryManager。   

按照上面的设想改进内存分配器 。        【未完成】    


2017年11月26日17:04:42：
[commit]
x2文件系统移植完成，正在设计二级加载器
----------
花了两天时间，完成了仅仅依靠接口的文件系统
这将使该文件系统具备完整的、100%的可移植性，并且也指明了将来对于内核其他部分的设计思想。
将BIOS看成0级加载器，MBR(VBR)看成1级加载器，将类grub的引导程序看成2级加载程序，从而实现内核的加载分层标准。目前已经完成了MBR的设计。


下一个commit补充：
1.启用了g++的-Wall -Werror, 编译不再允许潜在且明显的错误
2.修改README.md文件，搜索github上怎么相对引用
3.增加git的tag，从而标记每一个版本

2017年11月26日15:33:54：
一个小bug，malloc得来的内存，如果写超限，不会报错
但是free错误


2017年11月26日15:10:46：
修复了一个小bug，在定义函数时，使用::free而不是free


2017年11月26日15:00:04：
64位系统上应当使用fopen("file","r+")来读写之前的文件


2017年11月26日13:37:58：
现在，看上去SimpleMemoryNode配合其他类型是非常有效的方式，但是实际上非常愚蠢，这破坏了类的封装原则。

建议：所有的该类管理器换成Associate型管理器  【未完成】


2017年11月26日13:37:31：
解决了一个在类定义中引入其他的文件的bug
2017年11月26日11:04:56：
依赖图（不是依赖的问题）

File.h-->MallocToSimple.h
        |
        -->def.h
        |
        -->MemoryManager.h
        |
        --List.h
        |
        --Env.h
                            -->List.h
                            |
        -->MallocToSimple.h--->EnvInterface.h--def.h
        |
Env64.h-->Env.h-->def.h





2017年11月26日08:07:41：注，文件系统的filename分区是 <len,data>结构，而不是<data,0>

2017年11月25日23:42:12：EnvInterface中，应当将地址类型修改成系统的指针类型，也就是sizeof(void*),否则在64位系统上可能出现截断错误
直接将类型限定为u8_t*即可

2017年11月25日23:09:44：对于某种类型的文件，如果决定只在有限的模式下编译通过，则增加
```c++
\#if !defined(CODE64)
\#error "SPECIFIC for CODE64"
\#endif 
```
     【未完成】

2017年11月25日21:24:45：暂时将字符串处理为char数组和其长度，string类型之后再处理。

2017年11月25日17:59:29：总结一个设计原则：接口和实现分离在c++中也有较好的实现
2017年11月25日17:57:04： 目前已经完成了大部分文件系统的重构
内置一个env变量，不再有任何其他假设，不引入其他文件，除了Environment。
这就是接口设计的好处

2017年11月25日14:11:17：
EnvInterface需求分析
注：元信息的内存缓冲区分配以及信息的读入，这些由外部完成
写扇区 -- 将文件内容从内存位置写的扇区的某个位置
writeSectors(u32_t srcSeg,u32_t srcOff,u8_t driver,u32_t LBAlow,u32_t num,u32_t LBAhigh)

readSectors(u32_t dstSeg,u32_t dstOff,u8_t driver,u32_t LBAlow,u32_t num,u32_t LBAhigh);


int printf_simple(const char *fmt,...);

一个SimpleMemoryManager<TreeNode<MemoryDescriptor>>,一个SimpleMemoryManager<ListNode<LinearSourceDescriptor> >
T *getNew();
void withdraw(T *t);

这样一来，filenamemm将不知道具体的SimpleMemoryManager的类型

只需要继承MallocToSimple即可
将这个参数传递进去。。。

支持的string类型：即String Interface

回写操作可能按文件回写，也可能按磁盘回写；
64位系统忽略磁盘号，以文件名替代之；或者说，将磁盘号转换成文件名，将(LBA扇区号-[该分区起始扇区号])*512转换成文件偏移，将num转换成字节数量偏移即可

TreeNode<MemoryDescriptor> 
ListNode<LinearSourceDescriptor> 


一个简单版的printf函数，仅仅支持%x,%d,%c三种类型,用于输出调试信息。 

这些函数绝对不能作为宏实现

初始化前提假定：已经分配好了所有的元信息区域

2017年11月25日13:42:15：先测试64位模式下的读写，
增加命令
然后将所有用到的64位代码提取成EnvInterface
改变文件系统的实现，使用动态参数，这些参数一经指定，就写入第三个扇区
增加X2fsUtil的功能：读取元信息     【未完成】

2017年11月25日03:34:05：其实从整体来看，需求就是要求gcc能够尽量压缩代码的空间，不要将代码放到其他区域

2017年11月25日02:55:00：现在通过扩展的int0x13的42号中断来完成功能。
需要在将来添加检测0x13扩展中断的代码    【未完成】

2017年11月25日02:33:07：尝试在VS下编译整个工程
因为我发现eclipse并不是特别高效。    【未完成】

2017年11月25日01:20:57：启用编译器中的-Wall选项，启用全部警告信息     【完成】
同时启用了-Werror, 取消了--no-warnings

2017年11月25日00:59:13：
读取参数：dl=01 一个驱动器 dh=0xf
di=0xffac es=0x7c0
cx=0x133f
CF=0
bl=0

柱面：0x13
扇区数：0x3f
磁头数：0xf

2017年11月25日00:22:51： cx=554d, 但是开始扇区是0x3000

2017年11月25日00:17:47：此次MBR完成后，有必要在filesystem手册中增加一章详细的技术说明
包括禁止g++代码重排
启用-O优化，视情况选择合适的
其他一些语言上习以为常的事情必须经过检验。

2017年11月25日00:03:34：review所有的代码，确保使用char作为内部成员时，是无符号类型的，即u8_t

2017年11月24日19:39:36：现在将partitions_table文件删除，使用新的镜像文件替代之

2017年11月24日19:23:26： 使用g++的文件宏定义替代命令行参数传递   【未完成】

2017年11月24日19:20:04：从linux下新建了一个磁盘文件，用于替代旧的tools/bochs-run/main.bimg.clean文件
该文件的分区信息包括在同目录下的main.bimg.clean.info中

2017年11月24日16:04:19：修复了memcopy使用esp位置相关参数的bug

2017年11月24日15:26:27：基于MBRmain.cpp文件，针对该文件，是否可以启用优化选项？
2017年11月24日14:05:45：编译出VBRmain.bimg文件，然后将原来main.cpp(16位引导文件)修改成跳转到VBRmain.bimg文件
现在需要知道具体的分区信息，MBR明确地只能占用一个扇区，因此代码量不能过于庞大
确定激活扇区的位置，然后读入该扇区；为了仍然将其读到0x7c00处，所以MBR扇区的代码和栈需要移动到后面（栈之后的位置），然后跳转到该处继续执行，所有代码不能超过分区大小。

将main.cpp修改含义更加明确的MBRmain.cpp,生成文件名也改变  【完成】

image_16.ld改成image_mbr.ld 【完成】
image_32.ld改成image_kernel.ld 【完成】
2017年11月24日14:03:07：重新定义了表格准则法形式，现在放在一个文件文件夹中，对应pre,in_log,post三个过程
in_log可以附带后缀下标，表明时间区间
