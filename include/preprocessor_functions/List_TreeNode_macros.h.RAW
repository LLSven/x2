
/**
 * @param __DEF_ALIGNMENT
 */

#if !defined(__DEF_ALIGNMENT)
#error "please define __DEF_ALIGNMENT"
#endif

#define __DEF_TreeNode TreeNode<T,__DEF_ALIGNMENT>


template<class T>
typename __DEF_TreeNode::__TreeNode* __DEF_TreeNode::setSon(__TreeNode* son)
  {
#if defined(CODE64)
	//printf("setSon is : %x \n",son);
#endif
  	this->son=son;
  	return this;
  }
template<class T>
typename __DEF_TreeNode::__TreeNode* __DEF_TreeNode::setFather(__TreeNode* father) {
    this->father=father;
    return this;
}

//#if ! defined(CODE64)
template<class T>
typename __DEF_TreeNode::__TreeNode* __DEF_TreeNode::getSon() const{
//#if defined(CODE64)
//	printf("gettSon \n");
//#endif
	return son;
}
//#endif


template<class T>
typename __DEF_TreeNode::__TreeNode* __DEF_TreeNode::getNext() const{
	__TreeNode* next=(__TreeNode*)this->__ListNode::getNext();//这种情况下的强制转换一定是正确的，因为TreeNode中只存储TreeNode，而不会存储ListNode
	return next;
}

template<class T>
typename __DEF_TreeNode::__TreeNode* __DEF_TreeNode::getPrevious() const{
	__TreeNode* previous=(__TreeNode*)this->__ListNode::getPrevious();
	return previous;
}


template<class T>
typename __DEF_TreeNode::__TreeNode* __DEF_TreeNode::getDirectFather()const {//direct father
#if defined(CODE64)
//	printf("call direct,this is %x,father is %x\n",this,this->father);
#endif
    return father;
}

template<class T>
bool		 __DEF_TreeNode::hasSon()const
{
	return this->son!=NULL;
}
template<class T>
bool 		 __DEF_TreeNode::hasFather()const
{
	return this->father!=NULL;
}



#undef __DEF_TreeNode

#undef __DEF_ALIGNMENT
