
/**
 * @param __DEF_ALIGNMENT
 */

#if !defined(__DEF_ALIGNMENT)
#error "please define __DEF_ALIGNMENT"
#endif


#pragma pack(push,__DEF_ALIGNMENT)
template <class T>
class TreeNode<T,__DEF_ALIGNMENT>:public ListNode<T,__DEF_ALIGNMENT>{
public:
	using Super = ListNode<T,__DEF_ALIGNMENT>;
	using Father = Super;// Father is DEPRECATED
	using __ListNode = Father;
	using __TreeNode = TreeNode<T,__DEF_ALIGNMENT>;
public:
	TreeNode()=default;
    TreeNode(const T& data,__TreeNode* father=NULL,__TreeNode* son=NULL,__TreeNode* next=NULL,__TreeNode* previous=NULL);
    ~TreeNode();

    AS_MACRO __TreeNode* setSon(__TreeNode* son);//done
    AS_MACRO __TreeNode* setFather(__TreeNode* father);//done

//#if defined(CODE64)
//    __TreeNode* getSon()const;
//#else
    AS_MACRO __TreeNode* getSon()const; //done
//#endif
    AS_MACRO __TreeNode* getNext()const;
    AS_MACRO __TreeNode* getPrevious()const;

    AS_MACRO __TreeNode* getDirectFather()const;//direct father,done
    		void		addSon(__TreeNode* son);
    AS_MACRO bool		hasSon()const;
    AS_MACRO bool 		hasFather()const;

    void		insertSon(__TreeNode* son);
    void		insertFather(__TreeNode* father);
    __TreeNode*	removeSon();
	__TreeNode*	removeFather();
	void 			adjustOffset(ptrdiff_t diff);
	void			initToNull();


    __TreeNode* getParent()const;//往previous一直遍历，直到是根，然后返回根的father,done
    
protected:
    
    __TreeNode *son;
    __TreeNode *father;
    
};
#pragma pack(pop)


#undef __DEF_ALIGNMENT
